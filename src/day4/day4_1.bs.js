// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var List = require("bs-platform/lib/js/list.js");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var inputFilePath = Path.join(__dirname, "./input.txt");

function readFile(param) {
  return Fs.readFileSync(inputFilePath, "utf8").split("\n");
}

function print(_list) {
  while(true) {
    var list = _list;
    if (list) {
      console.log(list[0]);
      _list = list[1];
      continue ;
    } else {
      return /* () */0;
    }
  };
}

var timeRegex = (/\[(.*)\]/);

var guardRegex = (/#(\d{1,4})/);

function dateComparator(a, b) {
  var extractDate = function (line) {
    return new Date(Caml_array.caml_array_get(line.split(timeRegex), 1)).valueOf();
  };
  var difference = extractDate(a) - extractDate(b);
  if (difference > 0) {
    return 1;
  } else if (difference === 0) {
    return 0;
  } else {
    return -1;
  }
}

function chunkByGuard(lines) {
  var match = $$Array.to_list(lines);
  if (match) {
    var _lines = match[1];
    var _chunks = /* [] */0;
    var _currrentChunk = /* :: */[
      match[0],
      /* [] */0
    ];
    while(true) {
      var currrentChunk = _currrentChunk;
      var chunks = _chunks;
      var lines$1 = _lines;
      if (lines$1) {
        var rest = lines$1[1];
        var nextLine = lines$1[0];
        var match$1 = nextLine.includes("Guard");
        if (match$1) {
          _currrentChunk = /* :: */[
            nextLine,
            /* [] */0
          ];
          _chunks = Pervasives.$at(chunks, /* :: */[
                Pervasives.$at(currrentChunk, /* :: */[
                      nextLine,
                      /* [] */0
                    ]),
                /* [] */0
              ]);
          _lines = rest;
          continue ;
        } else {
          _currrentChunk = Pervasives.$at(currrentChunk, /* :: */[
                nextLine,
                /* [] */0
              ]);
          _lines = rest;
          continue ;
        }
      } else {
        return chunks;
      }
    };
  } else {
    return /* [] */0;
  }
}

function getTime(line) {
  return Js_primitive.null_to_opt(line.match(timeRegex));
}

function getGuardId(line) {
  return Js_primitive.null_to_opt(line.match(guardRegex));
}

function createSleepCycle(line, lastTimestamp, id) {
  var match = line.match(timeRegex);
  if (match !== null) {
    if (line.includes("Guard") || line.includes("falls asleep")) {
      return /* record */[
              /* id */id,
              /* start */lastTimestamp,
              /* end_ */Caml_array.caml_array_get(match, 1),
              /* sleeping */false
            ];
    } else if (line.includes("wakes up")) {
      return /* record */[
              /* id */id,
              /* start */lastTimestamp,
              /* end_ */Caml_array.caml_array_get(match, 1),
              /* sleeping */true
            ];
    } else {
      console.log("incorrect string found");
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "day4_1.re",
              67,
              6
            ]
          ];
    }
  } else {
    console.log("time not matched");
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "day4_1.re",
            71,
            4
          ]
        ];
  }
}

function createSleepCycles(guardChunk) {
  if (guardChunk) {
    var restOfChunk = guardChunk[1];
    var oneLine = guardChunk[0];
    if (restOfChunk) {
      var match = oneLine.match(timeRegex);
      var match$1 = oneLine.match(guardRegex);
      var exit = 0;
      if (match !== null && match$1 !== null) {
        var _line = List.hd(restOfChunk);
        var _remainingLines = List.tl(restOfChunk);
        var _lastTimestamp = Caml_array.caml_array_get(match, 1);
        var _sleepCycles = /* [] */0;
        var guardId = Caml_array.caml_array_get(match$1, 1);
        while(true) {
          var sleepCycles = _sleepCycles;
          var lastTimestamp = _lastTimestamp;
          var remainingLines = _remainingLines;
          var line = _line;
          if (remainingLines) {
            var match$2 = line.match(timeRegex);
            if (match$2 !== null) {
              _sleepCycles = Pervasives.$at(sleepCycles, /* :: */[
                    createSleepCycle(line, lastTimestamp, guardId),
                    /* [] */0
                  ]);
              _lastTimestamp = Caml_array.caml_array_get(match$2, 1);
              _remainingLines = remainingLines[1];
              _line = remainingLines[0];
              continue ;
            } else {
              console.log("failed to parse time");
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "day4_1.re",
                      97,
                      8
                    ]
                  ];
            }
          } else {
            var match$3 = line.match(timeRegex);
            if (match$3 !== null) {
              return Pervasives.$at(sleepCycles, /* :: */[
                          createSleepCycle(line, lastTimestamp, guardId),
                          /* [] */0
                        ]);
            } else {
              console.log("Could not parse time");
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "day4_1.re",
                      83,
                      8
                    ]
                  ];
            }
          }
        };
      } else {
        exit = 1;
      }
      if (exit === 1) {
        console.log("no guards left");
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "day4_1.re",
                116,
                6
              ]
            ];
      }
      
    } else {
      return /* [] */0;
    }
  } else {
    return /* [] */0;
  }
}

var asleepByGuard = { };

var asleepByMinute = { };

function recordTimeAsleep(sleepCycle) {
  var sleepCycleLength = ((new Date(sleepCycle[/* end_ */2]).valueOf() - new Date(sleepCycle[/* start */1]).valueOf() | 0) / 1000 | 0) / 60 | 0;
  var match = asleepByGuard[sleepCycle[/* id */0]];
  if (match !== undefined) {
    asleepByGuard[sleepCycle[/* id */0]] = match + sleepCycleLength | 0;
    return /* () */0;
  } else {
    asleepByGuard[sleepCycle[/* id */0]] = sleepCycleLength;
    return /* () */0;
  }
}

var sleepLogs = List.filter((function (log) {
          return log[/* sleeping */3];
        }))(List.flatten(List.map(createSleepCycles, chunkByGuard(Fs.readFileSync(inputFilePath, "utf8").split("\n").sort(dateComparator)))));

List.iter(recordTimeAsleep, sleepLogs);

var sleepiestGuard = $$Array.fold_left((function (param, param$1) {
          var timeSleep = param$1[1];
          var maxTimeSleep = param[1];
          var match = maxTimeSleep > timeSleep;
          if (match) {
            return /* tuple */[
                    param[0],
                    maxTimeSleep
                  ];
          } else {
            return /* tuple */[
                    param$1[0],
                    timeSleep
                  ];
          }
        }), /* tuple */[
        "id",
        2
      ], Js_dict.entries(asleepByGuard))[0];

console.log(sleepiestGuard);

function timeAleepByMinute(guardId, sleepLogs) {
  return List.iter((function (log) {
                var start = new Date(log[/* start */1]);
                var end_ = new Date(log[/* end_ */2]);
                var startMinute = start.getMinutes() | 0;
                var endMinute = end_.getMinutes() | 0;
                for(var minute = startMinute ,minute_finish = endMinute - 1 | 0; minute <= minute_finish; ++minute){
                  var minuteKey = String(minute);
                  var match = asleepByMinute[minuteKey];
                  if (match !== undefined) {
                    asleepByMinute[minuteKey] = match + 1 | 0;
                  } else {
                    asleepByMinute[minuteKey] = 1;
                  }
                }
                return /* () */0;
              }), List.filter((function (log) {
                      return log[/* id */0] === guardId;
                    }))(sleepLogs));
}

timeAleepByMinute(sleepiestGuard, sleepLogs);

console.log(asleepByMinute);

exports.inputFilePath = inputFilePath;
exports.readFile = readFile;
exports.print = print;
exports.timeRegex = timeRegex;
exports.guardRegex = guardRegex;
exports.dateComparator = dateComparator;
exports.chunkByGuard = chunkByGuard;
exports.getTime = getTime;
exports.getGuardId = getGuardId;
exports.createSleepCycle = createSleepCycle;
exports.createSleepCycles = createSleepCycles;
exports.asleepByGuard = asleepByGuard;
exports.asleepByMinute = asleepByMinute;
exports.recordTimeAsleep = recordTimeAsleep;
exports.sleepLogs = sleepLogs;
exports.sleepiestGuard = sleepiestGuard;
exports.timeAleepByMinute = timeAleepByMinute;
/* inputFilePath Not a pure module */
