// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var List = require("bs-platform/lib/js/list.js");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");

var inputFilePath = Path.join(__dirname, "./input.txt");

function readFile(param) {
  return Fs.readFileSync(inputFilePath, "utf8").split("\n");
}

function parseClaim(line) {
  var id = Caml_format.caml_int_of_string(Caml_array.caml_array_get(line.split("@"), 0).trim().slice(1));
  var otherHalf = Caml_array.caml_array_get(line.split("@"), 1).trim().split(": ");
  var position = Caml_array.caml_array_get(otherHalf, 0);
  var dimensions = Caml_array.caml_array_get(otherHalf, 1);
  return /* record */[
          /* id */id,
          /* row */Caml_format.caml_int_of_string(Caml_array.caml_array_get(position.split(","), 1)),
          /* col */Caml_format.caml_int_of_string(Caml_array.caml_array_get(position.split(","), 0)),
          /* width */Caml_format.caml_int_of_string(Caml_array.caml_array_get(dimensions.split("x"), 0)),
          /* height */Caml_format.caml_int_of_string(Caml_array.caml_array_get(dimensions.split("x"), 1))
        ];
}

var grid = $$Array.make_matrix(1000, 1000, 0);

function getCoordsOfClaim(claim) {
  var coords = /* [] */0;
  for(var row = claim[/* row */1] ,row_finish = (claim[/* row */1] + claim[/* height */4] | 0) - 1 | 0; row <= row_finish; ++row){
    for(var col = claim[/* col */2] ,col_finish = (claim[/* col */2] + claim[/* width */3] | 0) - 1 | 0; col <= col_finish; ++col){
      coords = /* :: */[
        /* tuple */[
          row,
          col
        ],
        coords
      ];
    }
  }
  return coords;
}

function applyClaimToGrid(claim) {
  var coords = getCoordsOfClaim(claim);
  List.iter((function (param) {
          var col = param[1];
          var row = param[0];
          var match = Caml_array.caml_array_get(Caml_array.caml_array_get(grid, row), col);
          if (match !== 0) {
            if (match !== 1) {
              return /* () */0;
            } else {
              return Caml_array.caml_array_set(Caml_array.caml_array_get(grid, row), col, 2);
            }
          } else {
            return Caml_array.caml_array_set(Caml_array.caml_array_get(grid, row), col, 1);
          }
        }), coords);
  return claim;
}

function doesNotIntersect(claim) {
  var _coords = getCoordsOfClaim(claim);
  while(true) {
    var coords = _coords;
    if (List.length(coords) === 0) {
      return true;
    } else {
      var match = List.hd(coords);
      var match$1 = Caml_array.caml_array_get(Caml_array.caml_array_get(grid, match[0]), match[1]);
      if (match$1 !== 1) {
        return false;
      } else {
        _coords = List.tl(coords);
        continue ;
      }
    }
  };
}

console.log(List.filter(doesNotIntersect)($$Array.to_list($$Array.map(applyClaimToGrid, $$Array.map(parseClaim, Fs.readFileSync(inputFilePath, "utf8").split("\n"))))));

var width = 1000;

var height = 1000;

exports.inputFilePath = inputFilePath;
exports.readFile = readFile;
exports.parseClaim = parseClaim;
exports.width = width;
exports.height = height;
exports.grid = grid;
exports.getCoordsOfClaim = getCoordsOfClaim;
exports.applyClaimToGrid = applyClaimToGrid;
exports.doesNotIntersect = doesNotIntersect;
/* inputFilePath Not a pure module */
